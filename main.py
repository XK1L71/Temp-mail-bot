# main.py
# Telegram Temporary Mail Bot (English version, ready with your token + "Generated by Shakil")

import asyncio
import aiohttp
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

BOT_TOKEN = "8455111408:AAFG0doukDgec2jVBafKvzGOVTxnXLxeXCk"
PORT = 8080
POLL_INTERVAL = 10

API_BASE = "https://www.1secmail.com/api/v1/"
USER_INBOXES = {}  # user_id -> list of inbox dicts

# === Helper functions ===
async def generate_random_address(session):
    url = API_BASE + "?action=genRandomMailbox&count=1"
    async with session.get(url) as r:
        data = await r.json()
        addr = data[0]
        login, domain = addr.split("@")
        return {"address": addr, "login": login, "domain": domain}

async def check_messages(session, login, domain):
    params = {"action": "getMessages", "login": login, "domain": domain}
    async with session.get(API_BASE, params=params) as r:
        return await r.json()

async def get_message(session, login, domain, msg_id):
    params = {"action": "readMessage", "login": login, "domain": domain, "id": msg_id}
    async with session.get(API_BASE, params=params) as r:
        return await r.json()

# === Telegram commands ===
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    t = (
        "👋 Welcome!\n\n"
        "I am a Temporary Mail Bot.\n\n"
        "✉️ /new → get a new temporary email\n"
        "📋 /list → show your addresses\n"
        "🗑️ /remove <address> → remove an address\n\n"
        "Note: This uses the 1secmail public API — do not use for sensitive data.\n\n"
        "⚡ Generated by Shakil"
    )
    await update.message.reply_text(t)

async def new_address(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    async with aiohttp.ClientSession() as session:
        addr = await generate_random_address(session)
    USER_INBOXES.setdefault(uid, []).append(addr)
    await update.message.reply_text(f"✅ New address:\n`{addr['address']}`", parse_mode="Markdown")

async def list_addresses(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    inboxes = USER_INBOXES.get(uid, [])
    if not inboxes:
        await update.message.reply_text("❌ You have no addresses. Use /new to generate one.")
        return
    text = "📋 Your addresses:\n" + "\n".join([f"- {i['address']}" for i in inboxes])
    await update.message.reply_text(text)

async def remove_address(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    if not context.args:
        await update.message.reply_text("Usage: /remove <address>")
        return
    addr = context.args[0].strip()
    inboxes = USER_INBOXES.get(uid, [])
    USER_INBOXES[uid] = [i for i in inboxes if i['address'] != addr]
    await update.message.reply_text(f"🗑️ Address removed (if existed): {addr}")

# === Background task ===
async def background_checker(app):
    seen = {}
    async with aiohttp.ClientSession() as session:
        while True:
            try:
                for uid, inboxes in list(USER_INBOXES.items()):
                    for inbox in inboxes:
                        key = inbox["address"]
                        msgs = await check_messages(session, inbox["login"], inbox["domain"])
                        if not isinstance(msgs, list):
                            continue
                        for m in msgs:
                            mid = m.get("id")
                            if mid is None:
                                continue
                            seen.setdefault(key, set())
                            if mid in seen[key]:
                                continue
                            full = await get_message(session, inbox["login"], inbox["domain"], mid)
                            sender = full.get("from", "unknown")
                            subject = full.get("subject", "(no subject)")
                            body = full.get("body", "")
                            text = (
                                f"📩 New mail for `{key}`\n"
                                f"From: {sender}\n"
                                f"Subject: {subject}\n\n"
                                f"{body[:4000]}"
                            )
                            try:
                                await app.bot.send_message(chat_id=uid, text=text, parse_mode="Markdown")
                            except Exception as e:
                                print("Send failed:", e)
                            seen[key].add(mid)
                await asyncio.sleep(POLL_INTERVAL)
            except Exception as e:
                print("BG error:", e)
                await asyncio.sleep(5)

# === Web server ===
async def start_webserver():
    from aiohttp import web
    async def handle(request):
        return web.Response(text="OK")
    web_app = web.Application()
    web_app.router.add_get("/", handle)
    runner = web.AppRunner(web_app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', PORT)
    await site.start()
    print(f"🌐 Web server started on port {PORT}")

def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("new", new_address))
    app.add_handler(CommandHandler("list", list_addresses))
    app.add_handler(CommandHandler("remove", remove_address))
    # background tasks
    app.post_init.append(lambda a: asyncio.create_task(start_webserver()))
    app.post_init.append(lambda a: asyncio.create_task(background_checker(a)))
    print("🚀 Bot starting ...")
    app.run_polling()

if __name__ == "__main__":
    main()
